<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd">
<?xml-stylesheet type="text/xsl" href="/oooxhtml/oooxhtml.xsl"?><html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">@page {margin-top:2cm;margin-bottom:2cm;margin-left:2cm;margin-right:2cm;}</style>
    <title>Предметно-ориентированное проектирование</title>
    <meta name="generator" content="oooxhtml/1.4"/>
    <meta name="HeadURL" content="$HeadURL$"/>
  </head>
  <body>
    <div class="container text">
      <h1 id="predmetno-orientirovannoe_proektirovanie">
        <a class="anchor" href="#predmetno-orientirovannoe_proektirovanie">Предметно-ориентированное проектирование</a>
      </h1>
      <h2 id="opredelenie">
        <a class="anchor" href="#opredelenie">Определение</a>
      </h2>
      <p>Проектирование на основе предметной области (Domain Driven Design, DDD) – это объектно- ориентированный подход к проектированию ПО, основанный на предметной области, ее элементах, поведении и отношениях между ними. Целью является создание программных систем, являющихся реализацией лежащей в основе предметной области, путем определения модели предметной области, выраженной на языке специалистов в этой области. Модель предметной области может рассматриваться как каркас, на основании которого будут реализовываться решения.</p>
      <h2 id="celi">
        <a class="anchor" href="#celi">Цели</a>
      </h2>
      <p>DDD — инструмент для обсуждения идей реализации продукта, еще до того как будет написан код. Целью внедрения DDD и принципов SOLID — перестать разрабатывать хрупкий код, ломающийся от каждого изменения. В конечном итоге применение DDD совместно с TDD должно снизить стоимость сопровождения программных продуктов (снизить количество тикетов после релизов, облегчить раннюю диагностику ошибок на этапе разработки).</p>
      <h2 id="stoimost_">
        <a class="anchor" href="#stoimost_">Стоимость</a>
      </h2>
      <p>Предметно-ориентированное программирование вносит определенные издержки на проектирование и реализацию сущностей. Проектировать предметную область следует по принципу необходимого и достаточного усложнения, так любая избыточная сложность усложняет понимание. Хороший пример итеративного усложнения предметной области можно увидеть в главе <a href="https://martinfowler.com/apsupp/accounting.pdf">Accounting Patterns</a> книги <a href="https://martinfowler.com/books/ap.html">Analysis Patterns</a> Мартина Фаулера.</p>
      <h2 id="princip__razrabotki">
        <a class="anchor" href="#princip__razrabotki">Принципы разработки</a>
      </h2>
      <ol>
        <li>
          <p>SOLID, см. «Чистый код», «Чистая архитектура» Роберта Мартина</p>
        </li>
        <li>
          <p>Сущности должны отражать моделируемую предметную область</p>
        </li>
        <li>
          <p>Ограничивайте изменяемость (<b>final</b> в Java)</p>
        </li>
        <li>
          <p><a href="#cistaj_logika">Чистая логика</a>. Отделяйте бизнес-логику от других слоев приложения (сущности не должны не иметь методов работы с БД, сетью). Сущности могут иметь аннотации (spring, persistance и другие. Наличие аннотаций не является препятствием для того, чтобы создать нужные объекты для теста)</p>
        </li>
        <li>
          <p>Создавайте небольшие сущности для конкретных действий (<b>S</b>ingle Responsibility в Solid). Даже незначительные изменения в больших классах могут быть не тривиальной задачей. Избегайте GOD-объектов с бесконечной функциональностью, они являются копилкой технического долга.</p>
        </li>
        <li>
          <p>Для работы с БД и сетевыми ресурсами используются репозитории, шлюзы и т. п., с возможностью создания заглушек («mocks») для тестирования.</p>
        </li>
      </ol>
      <h2 id="otnosenij">
        <a class="anchor" href="#otnosenij">Отношения</a>
      </h2>
      <p>В методологии DDD предметная область описывается сущностями и их отношениями.</p>
      <p>Рассмотрим 3 основных вида отношений между сущностями: является (<i>is</i>), содержит (<i>has</i>), использует (<i>uses</i>).</p>
      <p>Примеры:</p>
      <p>Автомобиль <i>является</i> транспортным средством.</p>
      <p>Автомобиль <i>содержит</i> двигатель.</p>
      <p>Водитель <i>использует</i> автомобиль (можно употреблять конкретный глагол, например "ведет")</p>
      <h3 id="otnosenie__jvljetsj___is_">
        <a class="anchor" href="#otnosenie__jvljetsj___is_">Отношение «является» (is)</a>
      </h3>
      <p>Отношение «является» показывает общность поведения сущности. Данное отношение должно соответствовать <a href="https://ru.wikipedia.org/wiki/Принцип_подстановки_Барбары_Лисков">принципу подстановки Барбары Лисков (LSP)</a>(буква L в <a href="https://ru.wikipedia.org/wiki/SOLID_(объектно-ориентированное_программирование)">SOLID</a>).</p>
      <p>Данное отношение появляется в предметной области тогда, когда сущности начинают реализовывать общее поведение.</p>
      <p>Примеры</p>
      <p>Автомобиль <i>является</i> транспортным средством.</p>
      <p>Грузовик <i>является</i> транспортным средством.</p>
      <p>Транспортное средство можно <i>завести</i>.</p>
      <p>Принцип LSP означает, что любая функция, использующая метод <i>Транспортное средство.завести()</i> не должна зависеть от того, какого типа конкретный экземпляр транспортного средства передан.</p>
      <h3 id="otnosenie__soderzit___has_">
        <a class="anchor" href="#otnosenie__soderzit___has_">Отношение «содержит» (has)</a>
      </h3>
      <p>Отношение «содержит» определяет состав сущностей.</p>
      <p>В описании сущности следует приводить не все ее свойства, а только существенные в данной ситуации. Описывая состав сущности, мы мысленно «разбираем» ее на части. При этом, как правило, используется такой приём: сначала называется небольшое число крупных частей, затем каждая из них «разбирается» на части поменьше и так далее.</p>
      <h3 id="otnosenie__ispol_zuet___uses_">
        <a class="anchor" href="#otnosenie__ispol_zuet___uses_">Отношение «использует» (uses)</a>
      </h3>
      <p>Отношение «использует» описывает случай, когда сущности не связаны напрямую, а используется в качестве аргументов.</p>
      <h2 id="cistaj_logika">
        <a class="anchor" href="#cistaj_logika">Чистая логика</a>
      </h2>
      <p><a href="https://ru.wikipedia.org/wiki/Чистота_функции">Чистая функция</a> обладает следующими свойствами:</p>
      <ol>
        <li>
          <p>является детерминированной;</p>
        </li>
        <li>
          <p>не обладает побочными эффектами (не работает с глобальными переменными, базами данных, файлами, сетью).</p>
        </li>
      </ol>
      <p>Вы должны моделировать большую часть вашей логики чистыми функциями (классами) для того, чтобы она могла быть повторно используемой и тестируемой.</p>
      <p>Так как результат чистой функции зависит только от входных аргументов, и не зависит от состояния всей остальной системы, она требуем меньше тестов для проверки. Поскольку она не содержит побочных эффектов, контекст для нее проще подготовить. Вы просто вызываете конструктор класса или функцию с нужными данными и проверяете результат.</p>
      <h2 id="sloi_prilozenij">
        <a class="anchor" href="#sloi_prilozenij">Слои приложения</a>
      </h2>
      <h3 id="sloj_predmetnoj_oblasti">
        <a class="anchor" href="#sloj_predmetnoj_oblasti">Слой предметной области</a>
      </h3>
      <p>Создание слоя предметной области является главной целью создания приложения. Слой состоит из небольших сущностей, реализующих бизнес-логику. Бизнес-логика - это моделирование объектов и процессов предметной области (т.е. реального мира). Бизнес-логика может включать в себя:</p>
      <ol>
        <li>
          <p>Как данные преобразовываются или вычисляются. Например, вычисление суммы комиссионных или налога.</p>
        </li>
        <li>
          <p>Как данные передаются людям или программным компонентам (описывают бизнес-процесс)</p>
        </li>
      </ol>
      <h3 id="sloj_sluzb">
        <a class="anchor" href="#sloj_sluzb">Слой служб</a>
      </h3>
      <p>При анализе кода часто можно увидеть разбухшие доменные модели с огромным числом методов, что, как правило, объясняется посторонними обязанностями класса. Для того, чтобы избежать появления классов с множествами обязанностей следует интерфейсы доступа к домену.</p>
      <p>
        <cite>Слой служб устанавливает множество доступных действий и координирует отклик приложения на каждое действие. - “Patterns of Enterprise Application Architecture”</cite>
      </p>
      <p>Из книги “Patterns of Enterprise Application Architecture” by Martin Fowler, Randy Stafford.</p>
      <p>
        <cite>Двумя базовыми вариантами реализации слоя служб являются создание интерфейса доступа к домену (domain facade) и конструирование сценария операции (operation script). При использовании подхода, связанного с интерфейсом доступа к домену, слой служб реализуется как набор “тонких” интерфейсов, размещенных “поверх” модели предметной области. В классах, реализующих интерфейсы, никакая бизнес-логика отражения не находит — она сосредоточена исключительно в контексте модели предметной области. Тонкие интерфейсы устанавливают границы и определяют множество операций, посредством которых клиентские слои взаимодействуют с приложением, обнаруживая тем самым характерные свойства слоя служб.</cite>
      </p>
      <p>
        <cite>Создавая сценарий операции, вы реализуете слой служб как множество более “толстых” классов, которые непосредственно воплощают в себе логику приложения, но за бизнес-логикой обращаются к классам домена. Операции, предоставляемые клиентам слоя служб, реализуются в виде сценариев, создаваемых группами в контексте классов, каждый из которых определяет некоторый фрагмент соответствующей логики. Подобные классы, расширяющие супертип слоя (Layer Supertype, 491) и уточняющие объявленные в нем абстрактные характеристики поведения и сферы ответственности, формируют “службы” приложения (в названиях служебных типов принято употреблять суффикс “Service”). Слой служб и заключает в себе эти прикладные классы.</cite>
      </p>
      <h2 id="vnedrenie_zavisimostej">
        <a class="anchor" href="#vnedrenie_zavisimostej">Внедрение зависимостей</a>
      </h2>
      <p>Используйте инверсию управления в виде “Внедрения зависимостей” <a href="https://martinfowler.com/articles/injection.html">Dependency Injection</a> (DI). Внедрение зависимостей облегчает тестирование и параллельную разработку ПО (например, в случаях, когда вызываемые компоненты еще не готовы, для них создаются заглушки)</p>
      <p>
        <cite>Истинное внедрение зависимостей идет еще на один шаг вперед. Класс не предпринимает непосредственных действий по разрешению своих зависимостей; он остается абсолютно пассивным. Вместо этого он предоставляет set-методы и/или аргументы конструктора, используемые для внедрения зависимостей. В процессе конструирования контейнер DI создает экземпляры необходимых объектов (обычно по требованию) и использует аргументы конструктора или set-методы для скрепления зависимостей. Фактически используемые зависимые объекты задаются в конфигурационном файле или на программном уровне в специализированном конструирующем модуле.</cite>
      </p>
      <h3 id="preimusestva_vnedrenij_zavisimostej">
        <a class="anchor" href="#preimusestva_vnedrenij_zavisimostej">
          <cite>Преимущества внедрения зависимостей</cite>
        </a>
      </h3>
      <h4 id="podderzivaem_j_kod">
        <a class="anchor" href="#podderzivaem_j_kod">
          <cite>Поддерживаемый код</cite>
        </a>
      </h4>
      <p>
        <cite>Простые, автономные классы легче исправить, чем сложные, тесно связанные классы.</cite>
      </p>
      <p>
        <cite>Если ваши классы слабо связаны и следуют принципу единой ответственности, ваш код будет легче поддерживать.</cite>
      </p>
      <p>
        <cite/>
      </p>
      <p>
        <cite>Поддерживаемый код имеет более низкую общую стоимость владения. Затраты на обслуживание часто превышают затраты на создание кода в первую очередь, поэтому все, что повышает удобство сопровождения вашего кода — хорошо.</cite>
      </p>
      <h4 id="testiruemost_">
        <a class="anchor" href="#testiruemost_">
          <cite>Тестируемость</cite>
        </a>
      </h4>
      <p>
        <cite>Код, который легко проверить, тестируется лучше. Больше тестирования означает более высокое качество и надежность кода.</cite>
      </p>
      <p>
        <cite>Слабо связанные классы с одной ответственностью очень просты для модульного тестирования.</cite>
      </p>
      <p>
        <cite>Если вы передаете зависимости в классы, создать дублирующую тестовую реализацию будет просто. Если зависимости жестко запрограммированы, невозможно создать тестовые варианты для них.</cite>
      </p>
      <h4 id="citaemost_">
        <a class="anchor" href="#citaemost_">
          <cite>Читаемость</cite>
        </a>
      </h4>
      <p>
        <cite>Код с внедрением зависимостей более читаем. Благодаря функциональной декомпозиции код не перегружен ненужными деталями. Более читаемый код более удобен в сопровождении</cite>
      </p>
      <h4 id="gibkost_">
        <a class="anchor" href="#gibkost_">
          <cite>Гибкость</cite>
        </a>
      </h4>
      <p>
        <cite>Программное обеспечение должно быть способным изменяться и адаптироваться к новым требованиям. Слабосвязанный код является гибким и может адаптироваться к этим изменениям.</cite>
      </p>
      <p>Небольшие классы, которые делают что-то одно, легче собрать и использовать повторно в разных ситуациях.</p>
      <p>Маленькие классы похожи на Lego - их можно легко соединить, чтобы создать множество вариантов использования. Возможность повторного использования кода экономит время и деньги.</p>
      <h4 id="rassirjemost_">
        <a class="anchor" href="#rassirjemost_">Расширяемость</a>
      </h4>
      <p>Кодовая база приложения никогда не остается статичной, и вам, скорее всего, придется добавлять новые функции по мере роста вашей кодовой базы и возникновения новых требований. Расширяемый код отвечает этим требованиям.</p>
      <p>Небольшие, гибкие классы можно легко расширять либо наследованием, либо композицией.</p>
      <p>Код, использующий внедрение зависимостей, приводит к более расширяемой структуре классов. Полагаясь на абстракции вместо реализаций, приложение может легко варьировать нужную реализацию.</p>
      <p>Когда вы кодируете с использованием абстракций, вы можете положиться на то, что всегда возможна лучшая реализация того, что вы делаете и эта замена не будет стоить вам дорого.</p>
      <h4 id="komandnaj_razrabotka">
        <a class="anchor" href="#komandnaj_razrabotka">
          <cite>Командная разработка</cite>
        </a>
      </h4>
      <p>Внедрение зависимостей требует от вас кодирования абстракций, а не реализаций.</p>
      <p>Если вы работаете в команде, внедрение зависимостей облегчит развитие команды. (Даже если вы работаете в одиночку, ваша работа, вероятно, будет передана кому-то в будущем.)</p>
      <p>Вы можете определить абстракции перед выполнением реализаций. Затем каждый разработчик может написать свой код, используя абстракции, еще до того, как будут написаны реализации.</p>
      <p>
        <cite>Кроме того, поскольку код слабо связан, эти реализации не будут полагаться друг на друга, и поэтому их легко разделить между разработчиками</cite>
      </p>
      <h3 id="preimusestva_kodirovanij_s_interfejsami">
        <a class="anchor" href="#preimusestva_kodirovanij_s_interfejsami">
          <cite>Преимущества кодирования с интерфейсами</cite>
        </a>
      </h3>
      <h4 id="kodirovanie_pod_abstrakcii">
        <a class="anchor" href="#kodirovanie_pod_abstrakcii">
          <cite>Кодирование под абстракции</cite>
        </a>
      </h4>
      <p>Вы должны проектировать ваш код на столько свободным и слабо связанным, на сколько это возможно. Используя интерфейсы, вы описываете части программы как блоки лего. <i>Определяя количество "выступов" с той и другой стороны, вы гарантируете то, что реализация интерфейса будет подходящей.</i></p>
      <p>Если вы никогда не соединяетесь ни с чем, кроме интерфейсов, то это настолько слабосвязанно, насколько это возможно.</p>
      <h4 id="podklycaem_e_realizacii">
        <a class="anchor" href="#podklycaem_e_realizacii">Подключаемые реализации</a>
      </h4>
      <p>Классы должны разрабатываться и тестироваться изолированно с небольшим количеством внешних зависимостей или вообще без них. Разумеется, основная часть кода не может работать изолированно. Код всегда зависит от чего-то. Если ваш код зависит от интерфейса, а не от конкретной реализации, вы легко сможете подменить зависимость на этапе тестирования. Так же вы можете легко подключать различные реализации во время выполнения программы, реализующие различные сценарии работы.</p>
      <p>В будущем вы всегда можете найти лучшую реализацию интерфейса и подменить реализацию. Это позволит вам в том числе на ранних этапах разработки приложения создавать более простые реализации, которые можно будет улучшить в последствии.</p>
      <h4 id="mezmodul_naj_svjz_">
        <a class="anchor" href="#mezmodul_naj_svjz_">Межмодульная связь</a>
      </h4>
      <p>Интерфейсы позволяют организовать распределенную работу в командах. Различные модули приложения могут быть созданы различными разработчиками или командами. Отдавая реализацию модуля другой команде или разработчику, вы согласуете интерфейс и можете в даже не "копаться" в деталях реализации. </p>
      <h4 id="testiruem_j_kod">
        <a class="anchor" href="#testiruem_j_kod">Тестируемый код</a>
      </h4>
      <p>Интерфейсы делают ваш код тестируемым. Как отмечалось выше, поскольку вы используете интерфейсы, вы можете легко заменить любую реализацию, какую захотите. Что если вы тестируете и не хотите подключаться к производственной базе данных? Вы можете предоставить фиктивную реализацию для интерфейса подключения к базе данных - такую, которая только притворяется базой данных и возвращает консервированные данные, - и теперь вы можете тестировать свой код изолированно, фактически не подключаясь к базе данных</p>
      <h4 id="sablon_">
        <a class="anchor" href="#sablon_">Шаблоны</a>
      </h4>
      <p>Интерфейсы облегчают реализацию шаблонов проектирования и позволяют делают такие вещи, как Dependency Injection . Большинство шаблонов и практик, включая платформы внедрения зависимостей, доступны благодаря мощным и гибким интерфейсам. Шаблоны и архитектуры разработки, такие как Model-View-Controller (MVC) и Model-View-ViewModel (MVVM), намного проще реализовать и использовать при проектировании с интерфейсами.</p>
      <h2 id="instrument__proektrovanij">
        <a class="anchor" href="#instrument__proektrovanij">Инструменты проектрования</a>
      </h2>
      <ol>
        <li>
          <p><a href="http://plantuml.com/ru/">PlantUML</a>, <a href="http://plugins.netbeans.org/plugin/49069/plantuml">плагин NetBeans</a> и <a href="https://docs.ilb.ru/plantuml/">web-сервер для рисования диаграмм в браузере</a></p>
        </li>
      </ol>
    </div>
  </body>
</html>
