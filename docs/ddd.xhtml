<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" type="text/css" href="/oooxhtml/oooxhtml.css"/>
    <style type="text/css">@page {margin-top:2cm;margin-bottom:2cm;margin-left:2cm;margin-right:2cm;}</style>
    <title>Предметно-ориентированное проектирование</title>
    <meta name="generator" content="oooxhtml/1.3"/>
    <meta name="HeadURL" content="$HeadURL$"/>
  </head>
  <body>
    <div class="container text">
      <h1 id="predmetno-orientirovannoe_proektirovanie">
        <a class="anchor" href="#predmetno-orientirovannoe_proektirovanie">Предметно-ориентированное проектирование</a>
      </h1>
      <p>Проектирование предметной области - этап проектирования архитектуры программного обеспечения.</p>
      <p>На данном этапе мы должны иметь возможность обсуждения идей реализации продукта,</p>
      <p>еще до того как будет написан код.</p>
      <p>В методологии DDD предметная область описывается сущностями и их отношениями.</p>
      <p>Рассмотрим 3 основных вида отношений между сущностями: является (<i>is</i>), содержит (<i>has</i>), использует (<i>uses</i>).</p>
      <p>Примеры:</p>
      <p>Автомобиль <i>является</i> транспортным средством.</p>
      <p>Автомобиль <i>содержит</i> двигатель.</p>
      <p>Водитель <i>использует</i> автомобиль.</p>
      <h2 id="otnosenij">
        <a class="anchor" href="#otnosenij">Отношения</a>
      </h2>
      <h3 id="otnosenie__jvljetsj___is_">
        <a class="anchor" href="#otnosenie__jvljetsj___is_">Отношение «является» (is)</a>
      </h3>
      <p>Отношение «является» показывает общность поведения сущности. Данное отношение должно соответствовать <a href="https://ru.wikipedia.org/wiki/Принцип_подстановки_Барбары_Лисков">принципу подстановки Барбары Лисков (LSP)</a>(буква L в <a href="https://ru.wikipedia.org/wiki/SOLID_(объектно-ориентированное_программирование)">SOLID</a>).</p>
      <p>Данное отношение появляется в предметной области тогда, когда сущности начинают реализовывать общее поведение.</p>
      <p>Примеры</p>
      <p>Автомобиль <i>является</i> транспортным средством.</p>
      <p>Грузовик <i>является</i> транспортным средством.</p>
      <p>Транспортное средство можно <i>завести</i>.</p>
      <p>Принцип LSP означает, что любая функция, использующая метод <i>Транспортное средство.завести()</i> не должна зависеть от того, какого типа конкретный экземпляр транспортного средства передан.</p>
      <h3 id="otnosenie__soderzit___has_">
        <a class="anchor" href="#otnosenie__soderzit___has_">Отношение «содержит» (has)</a>
      </h3>
      <p>Отношение «содержит» определяет состав сущностей.</p>
      <p>В описании сущности следует приводить не все ее свойства, а только существенные в данной ситуации. Описывая состав сущности, мы мысленно «разбираем» ее на части. При этом, как правило, используется такой приём: сначала называется небольшое число крупных частей, затем каждая из них «разбирается» на части поменьше и так далее.</p>
      <h3 id="otnosenie__ispol_zuet___uses_">
        <a class="anchor" href="#otnosenie__ispol_zuet___uses_">Отношение «использует» (uses)</a>
      </h3>
      <p>Отношение «использует» описывает случай, когда сущности не связаны напрямую, а используется в качестве аргументов.</p>
      <h2 id="stoimost_">
        <a class="anchor" href="#stoimost_">Стоимость</a>
      </h2>
      <p>Предметно-ориентированное программирование вносит определенные издержки на проектирование и реализацию сущностей. Проектировать предметную область следует по принципу необходимого и достаточного усложнения, так любая избыточная сложность усложняет понимание. Хороший пример итеративного усложнения предметной области можно увидеть в главе <a href="https://martinfowler.com/apsupp/accounting.pdf">Accounting Patterns</a> книги <a href="https://martinfowler.com/books/ap.html">Analysis Patterns</a> Мартина Фаулера.</p>
      <h2 id="celi">
        <a class="anchor" href="#celi">Цели</a>
      </h2>
      <p>Целью внедрения DDD и принципов SOLID — перестать разрабатывать хрупкий код, ломающийся от каждого изменения. В конечном итоге применение DDD совместно с TDD должно снизить стоимость сопровождения программных продуктов (снизить количество тикетов после релизов, облегчить раннюю диагностику ошибок на этапе разработки).</p>
      <h2 id="princip__razrabotki">
        <a class="anchor" href="#princip__razrabotki">Принципы разработки</a>
      </h2>
      <ol>
        <li>
          <p>SOLID, см. «Чистый код», «Чистая архитектура» Роберта Мартина</p>
        </li>
        <li>
          <p>Сущности должны отражать моделируемую предметную область</p>
        </li>
        <li>
          <p>Ограничивайте изменяемость (<b>final</b> в Java)</p>
        </li>
        <li>
          <p><a href="#cistaj_logika">Чистая логика</a>. Отделяйте бизнес-логику от других слоев приложения (сущности не должны не иметь методов работы с БД, сетью). Сущности могут иметь аннотации (spring, persistance и другие. Наличие аннотаций не является препятствием для того, чтобы создать нужные объекты для теста)</p>
        </li>
        <li>
          <p>Создавайте небольшие сущности для конкретных действий (<b>S</b>ingle Responsibility в Solid). Даже незначительные изменения в больших классах могут быть не тривиальной задачей. Избегайте GOD-объектов с бесконечной функциональностью, они являются копилкой технического долга.</p>
        </li>
        <li>
          <p>Для работы с БД и сетевыми ресурсами используются репозитории, шлюзы и т. п., с возможностью создания заглушек («mocks») для тестирования.</p>
        </li>
      </ol>
      <h3 id="cistaj_logika">
        <a class="anchor" href="#cistaj_logika">Чистая логика</a>
      </h3>
      <p><a href="https://ru.wikipedia.org/wiki/Чистота_функции">Чистая функция</a> обладает следующими свойствами:</p>
      <ol>
        <li>
          <p>является детерминированной;</p>
        </li>
        <li>
          <p>не обладает побочными эффектами (не работает с глобальными переменными, базами данных, файлами, сетью).</p>
        </li>
      </ol>
      <p>Вы должны моделировать большую часть вашей логики чистыми функциями (классами) для того, чтобы она могла быть повторно используемой и тестируемой.</p>
      <p>Так как результат чистой функции зависит только от входных аргументов, и не зависит от состояния всей остальной системы, она требуем меньше тестов для проверки. Поскольку она не содержит побочных эффектов, контекст для нее проще подготовить. Вы просто вызываете конструктор класса или функцию с нужными данными и проверяете результат.</p>
      <h2 id="sloi_prilozenij">
        <a class="anchor" href="#sloi_prilozenij">Слои приложения</a>
      </h2>
      <h3 id="sloj_predmetnoj_oblasti">
        <a class="anchor" href="#sloj_predmetnoj_oblasti">Слой предметной области</a>
      </h3>
      <p>Создание слоя предметной области является главной целью создания приложения. Слой состоит из небольших сущностей, реализующих бизнес-логику. Бизнес-логика - это моделирование объектов и процессов предметной области (т.е. реального мира). Бизнес-логика может включать в себя:</p>
      <ol>
        <li>
          <p>Как данные преобразовываются или вычисляются. Например, вычисление суммы комиссионных или налога.</p>
        </li>
        <li>
          <p>Как данные передаются людям или программным компонентам (описывают бизнес-процесс)</p>
        </li>
      </ol>
      <h3 id="sloj_sluzb">
        <a class="anchor" href="#sloj_sluzb">Слой служб</a>
      </h3>
      <p>При анализе кода часто можно увидеть разбухшие доменные модели с огромным числом методов, что, как правило, объясняется посторонними обязанностями класса. Для того, чтобы избежать появления классов с множествами обязанностей следует интерфейсы доступа к домену.</p>
      <p>
        <span class="Citation">Слой служб устанавливает множество доступных действий и координирует отклик приложения на каждое действие. - “Patterns of Enterprise Application Architecture”</span>
      </p>
      <p>Из книги “Patterns of Enterprise Application Architecture” by Martin Fowler, Randy Stafford.</p>
      <p>
        <span class="Citation">Двумя базовыми вариантами реализации слоя служб являются создание интерфейса доступа к домену (domain facade) и конструирование сценария операции (operation script). При использовании подхода, связанного с интерфейсом доступа к домену, слой служб реализуется как набор “тонких” интерфейсов, размещенных “поверх” модели предметной области. В классах, реализующих интерфейсы, никакая бизнес-логика отражения не находит — она сосредоточена исключительно в контексте модели предметной области. Тонкие интерфейсы устанавливают границы и определяют множество операций, посредством которых клиентские слои взаимодействуют с приложением, обнаруживая тем самым характерные свойства слоя служб.</span>
      </p>
      <p>
        <span class="Citation">Создавая сценарий операции, вы реализуете слой служб как множество более “толстых” классов, которые непосредственно воплощают в себе логику приложения, но за бизнес-логикой обращаются к классам домена. Операции, предоставляемые клиентам слоя служб, реализуются в виде сценариев, создаваемых группами в контексте классов, каждый из которых определяет некоторый фрагмент соответствующей логики. Подобные классы, расширяющие супертип слоя (Layer Supertype, 491) и уточняющие объявленные в нем абстрактные характеристики поведения и сферы ответственности, формируют “службы” приложения (в названиях служебных типов принято употреблять суффикс “Service”). Слой служб и заключает в себе эти прикладные классы.</span>
      </p>
      <h2 id="inversij_upravlenij">
        <a class="anchor" href="#inversij_upravlenij">Инверсия управления</a>
      </h2>
      <p>Используйте инверсию управления в виде “Внедрения зависимостей” <a href="https://martinfowler.com/articles/injection.html">Dependency Injection</a> (DI). Внедрение зависимостей облегчает тестирование и параллельную разработку ПО (например, в случаях, когда вызываемые компоненты еще не готовы, для них создаются заглушки)</p>
      <p>
        <span class="Citation">Истинное внедрение зависимостей идет еще на один шаг вперед. Класс не предпринимает непосредственных действий по разрешению своих зависимостей; он остается абсолютно пассивным. Вместо этого он предоставляет set-методы и/или аргументы конструктора, используемые для внедрения зависимостей. В процессе конструирования контейнер DI создает экземпляры необходимых объектов (обычно по требованию) и использует аргументы конструктора или set-методы для скрепления зависимостей. Фактически используемые зависимые объекты задаются в конфигурационном файле или на программном уровне в специализированном конструирующем модуле.</span>
      </p>
      <h2 id="instrument__proektrovanij">
        <a class="anchor" href="#instrument__proektrovanij">Инструменты проектрования</a>
      </h2>
      <ol>
        <li>
          <p>
            <a href="https://umbrello.kde.org/">Umbrello</a>
          </p>
        </li>
        <li>
          <p><a href="https://jeddict.github.io/">Плагин NetBeans Jeddict</a> (<i>только для хранимых сущностей</i>)</p>
        </li>
        <li>
          <p><a href="http://plantuml.com/ru/">PlantUML</a>, <a href="http://plugins.netbeans.org/plugin/49069/plantuml">плагин NetBeans</a> и <a href="https://docs.ilb.ru/plantuml/">web-сервер для рисования диаграмм в браузере</a></p>
        </li>
        <li>
          <p>
            <a href="http://plugins.netbeans.org/plugin/55435/easyuml">Плагин NetBeans EasyUml</a>
          </p>
        </li>
        <li>
          <p>
            <a href="http://argouml.tigris.org/">ArgoUML</a>
          </p>
        </li>
        <li>
          <p>
            <a href="https://www.yworks.com/products/yed">Yed</a>
          </p>
        </li>
        <li>
          <p>
            <a href="https://www.modelio.org/">Modelio</a>
          </p>
        </li>
      </ol>
      <h1 id="resurs_">
        <a class="anchor" href="#resurs_">Ресурсы</a>
      </h1>
      <ol>
        <li>
          <p>
            <a href="https://portal2.bystrobank.ru/doctree/web/downloadFile.php?keyValue=25f31c831b010f9d527afb938553c4e90e14c261">
              <span class="Citation">Use Case DrivenObject Modelingwith UML</span>
            </a>
          </p>
        </li>
        <li>
          <p>
            <a href="http://www.kgau.ru/sveden/2017/ieu/metod_090303_20.pdf">
              <span class="Citation">Моделирование с помощью ArgoUML</span>
            </a>
          </p>
        </li>
        <li>
          <p>
            <a href="https://docs.ilb.ru/doc/scrapbook/development/s-o-l-i-d-principles-explained-in-five-minutes/">S.O.L.I.D Principles Explained In Five Minutes</a>
          </p>
        </li>
      </ol>
    </div>
    <script type="text/javascript" src="/privilegedAPI/web/scripts/privilegedAPI.js"></script>
    <script type="text/javascript" src="/oooxhtml/oooxhtml.js"></script>
  </body>
</html>
